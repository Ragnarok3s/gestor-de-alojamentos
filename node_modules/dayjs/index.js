const MS_PER = {
  millisecond: 1,
  second: 1000,
  minute: 60 * 1000,
  hour: 60 * 60 * 1000,
  day: 24 * 60 * 60 * 1000,
  week: 7 * 24 * 60 * 60 * 1000,
};

function pad(value, length = 2) {
  return String(value).padStart(length, '0');
}

function escapeRegex(text) {
  return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

const FORMAT_TOKENS = ['YYYY', 'MM', 'DD', 'HH', 'mm', 'ss'];
const TOKEN_REGEX = {
  YYYY: '(\\d{4})',
  MM: '(\\d{2})',
  DD: '(\\d{2})',
  HH: '(\\d{2})',
  mm: '(\\d{2})',
  ss: '(\\d{2})',
};

function parseByFormat(value, format) {
  let pattern = escapeRegex(format);
  const tokens = [];
  FORMAT_TOKENS.forEach(token => {
    if (pattern.includes(token)) {
      pattern = pattern.replace(token, TOKEN_REGEX[token]);
      tokens.push(token);
    }
  });
  const regex = new RegExp(`^${pattern}$`);
  const match = regex.exec(value);
  if (!match) return null;
  const result = {};
  tokens.forEach((token, idx) => {
    result[token] = Number.parseInt(match[idx + 1], 10);
  });
  return result;
}

function normalizeUnit(unit) {
  if (!unit) return '';
  const lower = String(unit).toLowerCase();
  if (lower.endsWith('s')) return lower.slice(0, -1);
  return lower;
}

class DayjsInstance {
  constructor(date, valid = true) {
    this.$d = date;
    this.$isValid = valid && !Number.isNaN(date.getTime());
  }

  isValid() {
    return !!this.$isValid;
  }

  clone() {
    return new DayjsInstance(new Date(this.$d.getTime()), this.$isValid);
  }

  valueOf() {
    return this.$d.getTime();
  }

  toDate() {
    return new Date(this.$d.getTime());
  }

  toISOString() {
    return this.$d.toISOString();
  }

  locale() {
    return this;
  }

  day() {
    return this.$d.getDay();
  }

  format(pattern = 'YYYY-MM-DDTHH:mm:ssZ') {
    if (!this.isValid()) return 'Invalid Date';
    const year = this.$d.getFullYear();
    const month = this.$d.getMonth() + 1;
    const day = this.$d.getDate();
    const hour = this.$d.getHours();
    const minute = this.$d.getMinutes();
    const second = this.$d.getSeconds();
    const replacements = {
      YYYY: pad(year, 4),
      MM: pad(month, 2),
      DD: pad(day, 2),
      HH: pad(hour, 2),
      mm: pad(minute, 2),
      ss: pad(second, 2),
    };
    let result = pattern;
    FORMAT_TOKENS.forEach(token => {
      result = result.replace(token, replacements[token]);
    });
    return result;
  }

  add(amount, unit) {
    const normalized = normalizeUnit(unit);
    const value = Number(amount) || 0;
    const date = new Date(this.$d.getTime());
    switch (normalized) {
      case 'day':
        date.setDate(date.getDate() + value);
        break;
      case 'week':
        date.setDate(date.getDate() + value * 7);
        break;
      case 'month': {
        const current = date.getDate();
        date.setDate(1);
        date.setMonth(date.getMonth() + value);
        const maxDay = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
        date.setDate(Math.min(current, maxDay));
        break;
      }
      case 'year':
        date.setFullYear(date.getFullYear() + value);
        break;
      case 'hour':
        date.setHours(date.getHours() + value);
        break;
      case 'minute':
        date.setMinutes(date.getMinutes() + value);
        break;
      case 'second':
        date.setSeconds(date.getSeconds() + value);
        break;
      default:
        date.setTime(date.getTime() + value);
    }
    return new DayjsInstance(date, this.$isValid);
  }

  subtract(amount, unit) {
    return this.add(-amount, unit);
  }

  diff(other, unit = 'millisecond') {
    const target = toDayjs(other);
    if (!this.isValid() || !target.isValid()) return NaN;
    const delta = this.$d.getTime() - target.$d.getTime();
    const normalized = normalizeUnit(unit);
    switch (normalized) {
      case 'day':
        return Math.trunc(delta / MS_PER.day);
      case 'hour':
        return Math.trunc(delta / MS_PER.hour);
      case 'minute':
        return Math.trunc(delta / MS_PER.minute);
      case 'second':
        return Math.trunc(delta / MS_PER.second);
      default:
        return delta;
    }
  }

  startOf(unit) {
    const normalized = normalizeUnit(unit);
    const date = new Date(this.$d.getTime());
    switch (normalized) {
      case 'year':
        date.setMonth(0);
        date.setDate(1);
        date.setHours(0, 0, 0, 0);
        break;
      case 'month':
        date.setDate(1);
        date.setHours(0, 0, 0, 0);
        break;
      case 'week': {
        date.setHours(0, 0, 0, 0);
        const diff = date.getDay();
        date.setDate(date.getDate() - diff);
        break;
      }
      case 'day':
      default:
        date.setHours(0, 0, 0, 0);
        break;
    }
    return new DayjsInstance(date, this.$isValid);
  }

  endOf(unit) {
    const normalized = normalizeUnit(unit);
    const start = this.startOf(normalized);
    switch (normalized) {
      case 'year':
        return start.add(1, 'year').subtract(1, 'millisecond');
      case 'month':
        return start.add(1, 'month').subtract(1, 'millisecond');
      case 'week':
        return start.add(1, 'week').subtract(1, 'millisecond');
      case 'day':
      default:
        return start.add(1, 'day').subtract(1, 'millisecond');
    }
  }

  isBefore(other) {
    const target = toDayjs(other);
    return this.$d.getTime() < target.$d.getTime();
  }

  isAfter(other) {
    const target = toDayjs(other);
    return this.$d.getTime() > target.$d.getTime();
  }

  isSameOrBefore(other) {
    const target = toDayjs(other);
    return this.$d.getTime() <= target.$d.getTime();
  }

  isSameOrAfter(other) {
    const target = toDayjs(other);
    return this.$d.getTime() >= target.$d.getTime();
  }

  isSame(other) {
    const target = toDayjs(other);
    return this.$d.getTime() === target.$d.getTime();
  }
}

function parseInput(input, format, strict) {
  if (input instanceof DayjsInstance) {
    return { date: new Date(input.$d.getTime()), valid: input.isValid() };
  }
  if (input instanceof Date) {
    return { date: new Date(input.getTime()), valid: !Number.isNaN(input.getTime()) };
  }
  if (typeof input === 'number') {
    const date = new Date(input);
    return { date, valid: !Number.isNaN(date.getTime()) };
  }
  if (Array.isArray(format)) {
    for (const candidate of format) {
      const parsed = parseInput(input, candidate, strict);
      if (parsed.valid) return parsed;
    }
    return { date: new Date(NaN), valid: false };
  }
  if (typeof format === 'string') {
    const parts = parseByFormat(String(input), format);
    if (!parts) return { date: new Date(NaN), valid: false };
    const year = parts.YYYY != null ? parts.YYYY : new Date().getFullYear();
    const month = parts.MM != null ? parts.MM - 1 : 0;
    const day = parts.DD != null ? parts.DD : 1;
    const hour = parts.HH != null ? parts.HH : 0;
    const minute = parts.mm != null ? parts.mm : 0;
    const second = parts.ss != null ? parts.ss : 0;
    const date = new Date(year, month, day, hour, minute, second);
    const valid =
      !Number.isNaN(date.getTime()) &&
      (!strict ||
        (date.getFullYear() === year &&
          date.getMonth() === month &&
          date.getDate() === day &&
          date.getHours() === hour &&
          date.getMinutes() === minute &&
          date.getSeconds() === second));
    return { date, valid };
  }
  if (input == null) {
    const date = new Date();
    return { date, valid: !Number.isNaN(date.getTime()) };
  }
  const parsed = new Date(input);
  return { date: parsed, valid: !Number.isNaN(parsed.getTime()) };
}

function toDayjs(input) {
  if (input instanceof DayjsInstance) return input;
  const { date, valid } = parseInput(input);
  return new DayjsInstance(date, valid);
}

function dayjs(input, format, strict) {
  const { date, valid } = parseInput(input, format, strict);
  return new DayjsInstance(date, valid);
}

dayjs.isDayjs = function (value) {
  return value instanceof DayjsInstance;
};

dayjs.extend = function (plugin) {
  if (typeof plugin === 'function') {
    plugin(null, DayjsInstance, dayjs);
  }
  return dayjs;
};

dayjs.locale = function () {
  return dayjs;
};

dayjs.Dayjs = DayjsInstance;

dayjs.max = function (...instances) {
  let maxInstance = null;
  instances.forEach(item => {
    const candidate = toDayjs(item);
    if (!candidate.isValid()) return;
    if (!maxInstance || candidate.valueOf() > maxInstance.valueOf()) {
      maxInstance = candidate;
    }
  });
  return maxInstance || dayjs(NaN);
};

dayjs.min = function (...instances) {
  let minInstance = null;
  instances.forEach(item => {
    const candidate = toDayjs(item);
    if (!candidate.isValid()) return;
    if (!minInstance || candidate.valueOf() < minInstance.valueOf()) {
      minInstance = candidate;
    }
  });
  return minInstance || dayjs(NaN);
};

module.exports = dayjs;
