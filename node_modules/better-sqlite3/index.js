const { spawnSync } = require('node:child_process');
const fs = require('node:fs');
const os = require('node:os');
const path = require('node:path');

function escapeValue(value) {
  if (value === null || value === undefined) return 'NULL';
  if (typeof value === 'number' || typeof value === 'bigint') {
    if (!Number.isFinite(Number(value))) return 'NULL';
    return String(value);
  }
  if (typeof value === 'boolean') {
    return value ? '1' : '0';
  }
  if (value instanceof Date) {
    return `'${value.toISOString().replace(/'/g, "''")}'`;
  }
  if (Buffer.isBuffer(value)) {
    return `X'${value.toString('hex')}'`;
  }
  return `'${String(value).replace(/'/g, "''")}'`;
}

function interpolate(sql, params) {
  if (!params || params.length === 0) return sql;
  if (params.length === 1 && params[0] && typeof params[0] === 'object' && !Array.isArray(params[0])) {
    const named = params[0];
    return sql.replace(/[@:$]([a-zA-Z0-9_]+)/g, (match, key) => {
      if (Object.prototype.hasOwnProperty.call(named, key)) {
        return escapeValue(named[key]);
      }
      return 'NULL';
    });
  }
  let index = 0;
  return sql.replace(/\?/g, match => {
    if (index >= params.length) return match;
    const value = escapeValue(params[index++]);
    return value;
  });
}

function runSqlite({ filename, sql, json = false }) {
  const args = [];
  if (json) args.push('-json');
  args.push(filename);
  const proc = spawnSync('sqlite3', args, { input: sql, encoding: 'utf8' });
  if (proc.error) throw proc.error;
  if (proc.status !== 0) {
    const err = new Error(proc.stderr.trim() || `sqlite3 exited with code ${proc.status}`);
    err.stderr = proc.stderr;
    err.stdout = proc.stdout;
    throw err;
  }
  return proc.stdout;
}

class Statement {
  constructor(db, sql) {
    this.db = db;
    this.sql = sql;
  }

  run(...params) {
    const formatted = interpolate(this.sql, params);
    const script = `${formatted};\nSELECT changes() AS changes, last_insert_rowid() AS last_insert_rowid;`;
    const output = runSqlite({ filename: this.db.filename, sql: script, json: true }).trim();
    const metaRows = output ? JSON.parse(output) : [];
    const meta = metaRows[metaRows.length - 1] || { changes: 0, last_insert_rowid: 0 };
    this.db._lastInsertRowid = Number(meta.last_insert_rowid) || 0;
    return {
      changes: Number(meta.changes) || 0,
      lastInsertRowid: Number(meta.last_insert_rowid) || 0,
    };
  }

  get(...params) {
    const normalized = this.sql.trim().toLowerCase();
    if (normalized.startsWith('select last_insert_rowid()')) {
      const match = /(?:as\s+)?([a-zA-Z_][a-zA-Z0-9_]*)/i.exec(
        this.sql.replace(/select\s+last_insert_rowid\(\)/i, '')
      );
      const key = match && match[1] ? match[1] : 'last_insert_rowid';
      return { [key]: this.db._lastInsertRowid || 0 };
    }
    const formatted = interpolate(this.sql, params);
    const output = runSqlite({ filename: this.db.filename, sql: `${formatted};`, json: true }).trim();
    if (!output) return undefined;
    const rows = JSON.parse(output);
    return rows[0];
  }

  all(...params) {
    const normalized = this.sql.trim().toLowerCase();
    if (normalized.startsWith('select last_insert_rowid()')) {
      const match = /(?:as\s+)?([a-zA-Z_][a-zA-Z0-9_]*)/i.exec(
        this.sql.replace(/select\s+last_insert_rowid\(\)/i, '')
      );
      const key = match && match[1] ? match[1] : 'last_insert_rowid';
      return [{ [key]: this.db._lastInsertRowid || 0 }];
    }
    const formatted = interpolate(this.sql, params);
    const output = runSqlite({ filename: this.db.filename, sql: `${formatted};`, json: true }).trim();
    if (!output) return [];
    return JSON.parse(output);
  }
}

class Database {
  constructor(filename = ':memory:') {
    if (filename === ':memory:' || !filename) {
      const tmp = fs.mkdtempSync(path.join(os.tmpdir(), 'better-sqlite3-'));
      this._tempDir = tmp;
      this.filename = path.join(tmp, 'database.sqlite');
    } else {
      this.filename = filename;
    }
  }

  prepare(sql) {
    return new Statement(this, sql);
  }

  exec(sql) {
    runSqlite({ filename: this.filename, sql });
    return this;
  }

  pragma(statement) {
    const normalized = String(statement || '').trim().replace(/^pragma\s+/i, '');
    runSqlite({ filename: this.filename, sql: `PRAGMA ${normalized};` });
  }

  transaction(fn) {
    if (typeof fn !== 'function') {
      throw new TypeError('Transaction requires a function callback');
    }
    const db = this;
    return function (...args) {
      return fn.apply(db, args);
    };
  }

  close() {
    if (this._tempDir) {
      try {
        fs.rmSync(this._tempDir, { recursive: true, force: true });
      } catch (_) {
        // ignore cleanup errors
      }
      this._tempDir = null;
    }
  }
}

module.exports = Database;
module.exports.default = Database;
